{
    "contents" : "#' @title Make Image VOI\n#'\n#' @description Creates a VOI of Image for the specified slices\n#' @param img Image (T1 usually or T2).  Array or object of class nifti \n#' @param slices Slices to take for the image voi\n#' @param na.rm Remove NAs from mean.  This is for double checking\n#' @param ... Arguments passed from other methods (not used)\n#' @export\n#' @return VOI of image.\nmake_img_voi = function(img, slices = 80:120, na.rm = TRUE, ...){\n  if (inherits(img, \"img_voi\")){\n    return(img)\n  }\n  img.voi = img[,,slices]  \n  mn = mean(img, na.rm=na.rm)\n  img.voi = img.voi[ img.voi > mn]\n  if (na.rm) img.voi = img.voi[!is.na(img.voi)]\n  class(img.voi) = \"img_voi\"\n  attr(img.voi, \"slices\") = slices\n  return(img.voi)\n}\n\n\n#' @title Performs White Stripe of T1 or T2 Images\n#'\n#' @description Returns the mean/sd of the whitestripe and indices\n#' for them on the image \n#' @param img Image (T1 or T2).  Array or object of class nifti \n#' @param type T1 or T2 image whitestripe\n#' @param breaks Number of breaks passed to \\code{\\link{hist}}\n#' @param whitestripe.width Radius of the white stripe\n#' @param whitestripe.width.l Lower Radius of the white stripe\n#' @param whitestripe.width.u Upper Radius of the white stripe\n#' @param arr.ind Whether indices should be array notation or not, \n#' passed to \\code{\\link{which}}\n#' @param verbose Print diagnostic information\n#' @param ... Arguments to be passed to \\code{\\link{get.last.mode}}\n#' @export\n#' @return List of indices of whitestripe, last mode of histogram,\n#' array/nifti of 0/1 corresponding to the mask,\n#' mean of whitestripe, standard deviation of whitestripe\n#' @examples \n#' \\dontrun{\n#' t1 = readNIfTI(system.file(\"T1Strip.nii.gz\", package=\"WhiteStripe\"))\n#' t1.ind = whitestripe(t1, \"T1\")\n#' t1.mask = whitestripe_ind_to_mask(t1, t1.ind$whitestripe.ind)\n#' t1.mask[t1.mask == 0] = NA\n#' orthographic(t1, t1.mask, col.y=\"red\") \n#' t2 = readNIfTI(system.file(\"T2Strip.nii.gz\", package=\"WhiteStripe\"))\n#' t2.ind = whitestripe(t2, \"T2\") \n#' t2.mask = whitestripe_ind_to_mask(t2, t2.ind$whitestripe.ind)\n#' t2.mask[t2.mask == 0] = NA\n#' orthographic(t2, t2.mask, col.y=\"red\")  \n#'}\nwhitestripe = function(img, type=c(\"T1\", \"T2\", \"last\", \"largest\"), breaks=2000, \n                       whitestripe.width = 0.05, \n                       whitestripe.width.l = whitestripe.width, \n                       whitestripe.width.u = whitestripe.width, \n                       arr.ind= FALSE, verbose = TRUE, ...){\n#   length.img = prod(dim(img))\n  if (verbose){\n    cat(paste0(\"Making \", type, \" Image VOI\\n\"))\n  }\n  img.voi = make_img_voi(img, ...)\n  if (verbose){\n    cat(paste0(\"Making \", type, \" Histogram\\n\"))\n  }\n  img.hist = hist(img.voi, \n                  breaks=breaks, \n                  plot=FALSE)\n  y.in = img.hist$counts\n  x.in = img.hist$mids\n  x.in = x.in[!is.na(y.in)];\n  y.in = y.in[!is.na(y.in)]\n  \n  stopifnot(length(type) == 1)\n  type = match.arg(type)\n  if (verbose){\n    cat(paste0(\"Getting \", type, \" Modes\\n\"))\n  }  \n  if (type %in% c(\"T1\", \"last\")) {\n    img.mode = get.last.mode(x.in, y.in, ...)\n  }\n  if (type %in% c(\"T1\", \"largest\")){\n    img.mode = get.largest.mode(x.in, y.in, ...) \n  }\n  img.mode.q = mean(img.voi < img.mode)\n  if (verbose){\n    cat(\"Quantile VOI\\n\")\n  }    \n  whitestripe = quantile(img.voi,\n                         probs=c(\n                           max(img.mode.q - whitestripe.width.l,0),\n                           min(img.mode.q + whitestripe.width.u,1)\n                         )\n  )\n  whitestripe.ind = which(\n    ( img > whitestripe[1]) & (img < whitestripe[2]) ,\n    arr.ind=arr.ind\n  )\n  err = FALSE\n  if (length(whitestripe.ind)==0) {\n    warning(paste0(\"Length of White Stripe is 0 for \", type, \n                   \", using whole brain normalization\"))\n    whitestripe.ind = which(img > mean(img))\n    err = TRUE\n  }\n  #ERROR IN WHITE STRIPE MEANS DO WHOLE-IMAGE NORMALIZATION\n  \n  mu.whitestripe = img.mode\n  sig.whitestripe = sd(img[whitestripe.ind])\n  #   \n  #     img.whitestripe.norm = (img-mu.whitestripe)/sig.whitestripe\n  #      \n  mask.img = img\n  mask.img[!is.na(mask.img) | is.na(mask.img)] = 0\n  mask.img[whitestripe.ind] = 1  \n  if (inherits(img, \"nifti\")){\n    mask.img = cal_img(mask.img)\n    mask.img = zero_trans(mask.img)\n  }  \n  \n  return( list(\n    whitestripe.ind = whitestripe.ind, \n    img.mode = img.mode, \n    mask.img = mask.img,\n    mu.whitestripe = mu.whitestripe,\n    sig.whitestripe = sig.whitestripe,\n    img.mode.q = img.mode.q,\n    whitestripe = whitestripe,\n    whitestripe.width = whitestripe.width,\n    whitestripe.width.l = whitestripe.width.l,\n    whitestripe.width.u = whitestripe.width.u,\n    err = err  ))\n}\n\n\n\n\n#' @title Normalize Image using white stripe\n#'\n#' @description Taking the indices from white stripe to normalize the \n#' intensity values of the brain\n#' @param img Array or object of class nifti\n#' @param indices Indices of white stripe from \\code{\\link{whitestripe}}\n#' @param ... arguments to be passed to \\code{\\link{mean}} and \\code{\\link{sd}}\n#' @export\n#' @return Object of same class as img, but normalized\nwhitestripe_norm = function(img, indices, ...){\n  mu = mean(img[indices], ...)\n  sig = sd(img[indices], ...)\n  img = (img-mu)/sig\n  if (inherits(img, \"nifti\")){\n    img = cal_img(img)\n    img = zero_trans(img)\n  }\n  return(img)\n}\n\n#' @title Hybrid WhiteStripe\n#'\n#' @description Uses t1 and t2 WhiteStripe to get an intersection of \n#' the two masks for a hybrid approach\n#' @param t1 T1 image, array or class nifti\n#' @param t2 T2 image, array or class nifti\n#' @param ... arguments passed to \\code{\\link{whitestripe}}\n#' @export\n#' @keywords hybrid, whitestripe\n#' @seealso whitestripe\n#' @return List of indices of overlap mask, and overlap of class array or nifti\n#' @aliases hybrid\n#' @examples \n#' \\dontrun{\n#' t1 = readNIfTI(system.file(\"T1Strip.nii.gz\", package=\"WhiteStripe\"))\n#' t2 = readNIfTI(system.file(\"T2Strip.nii.gz\", package=\"WhiteStripe\"))\n#' ind = whitestripe_hybrid(t1, t2)\n#'}\nwhitestripe_hybrid = function(t1, t2, ...){\n  t1.ws = whitestripe(t1, type=\"T1\", ...)\n  t2.ws = whitestripe(t2, type=\"T2\", ...)\n  whitestripe.ind = intersect(t1.ws$whitestripe.ind, \n    t2.ws$whitestripe.ind)\n  mask.img = t1\n  mask.img[!is.na(mask.img) | is.na(mask.img)] = 0\n  mask.img[whitestripe.ind] = 1  \n  if (inherits(t1, \"nifti\")){\n    mask.img = cal_img(mask.img)\n    mask.img = zero_trans(mask.img)\n  }    \n  return(list(\n    whitestripe.ind= whitestripe.ind,\n    mask.img = mask.img\n  ))\n}\n\n#' @title WhiteStripe Indices to Mask\n#'\n#' @description Uses WhiteStripe indices to create image mask\n#' @param img Array or class nifti that is corresponds to dimensions of the images the \n#' indices were generated from\n#' @param indices indices from \\code{\\link{whitestripe}}\n#' @param writeimg logical to write image or not\n#' @param ... arguments to passed to \\code{\\link{writeNIfTI}} for writing image\n#' @export\n#' @keywords hybrid, whitestripe\n#' @seealso whitestripe, whitestripe_hybrid\n#' @return Class of array or nifti depending on img input\n#' @aliases whitemask\n#' @import fslr\n#' @importFrom oro.nifti writeNIfTI\n#' @examples \n#' \\dontrun{\n#' t1 = readNIfTI(system.file(\"T1Strip.nii.gz\", package=\"WhiteStripe\"))\n#' t2 = readNIfTI(system.file(\"T2Strip.nii.gz\", package=\"WhiteStripe\"))\n#' ind = whitestripe_hybrid(t1, t2)\n#' mask = whitestripe_ind_to_mask(t1, ind$whitestripe.ind)\n#' orthographic(mask)\n#' } \nwhitestripe_ind_to_mask = function(img, indices, writeimg=FALSE, ...){\n  img[!is.na(img) | is.na(img)] = FALSE\n  img[indices] = TRUE\n  if (inherits(img, \"nifti\")){\n    img = cal_img(img)\n    img = zero_trans(img)\n    if (writeimg){\n      writeNIfTI(nim=img, ...)\n    }\n  } \n  \n  return(img)\n}\n\n\n\n#' @title Install dcm2nii tools\n#' @description Install dcm2nii to cttools for conversion tools \n#' @return NULL\n#' @export\ndownload_img_data = function(){\n  img_files = system.file(c(\"T1Strip.nii.gz\",\n                                \"T2Strip.nii.gz\"),\n                                package=\"WhiteStripe\")\n  \n  if (!all(file.exists(img_files))){\n    url = \"http://muschellij2.github.io/WhiteStripe/dcm2nii_files.zip\"\n    urlfile <- file.path(system.file(package=\"cttools\"), \"dcm2nii_files.zip\")\n    download.file(url, urlfile, quiet=TRUE)\n    files = unzip(urlfile, exdir = system.file(package=\"cttools\"))\n    for (ifile in files) system(sprintf(\"chmod +x %s\", ifile))\n    x = file.remove(urlfile)\n  }\n  dcm2nii_files = system.file(\"dcm2nii\", package= \"cttools\")  \n  return(file.exists(dcm2nii_files))\n}",
    "created" : 1402680333704.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "627617888",
    "id" : "595B9C21",
    "lastKnownWriteTime" : 1411406176,
    "path" : "~/Dropbox/Packages/WhiteStripe/R/whitestripe_ind.R",
    "project_path" : "R/whitestripe_ind.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}